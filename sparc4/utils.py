# This file is part of the SPARC4 Pipeline distribution
# https://github.com/sparc4-dev/sparc4-pipeline
# Copyright (c) 2023 Eder Martioli and Julio Campagnolo.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import glob
from copy import deepcopy

from astropy import units as u
from astropy.coordinates import AltAz, EarthLocation, SkyCoord
from astropy.io import fits
from astropy.time import Time, TimeDelta


def set_timecoords_keys(hdr, timezone=-3, timetype="", ra="", dec="",
                        set_airmass=True, time_key='DATE-OBS'):
    """ Pipeline module to set time and coordinates keywords
    Parameters
    ----------
    hdr : astropy.io.fits.Header
        FITS header unit to be updated
    timezone : int, optional
        Time zone of observations with respect to Greenwich.
        Default value is OPD's time zone of -3h
    timetype : str, optional
        if timetype=="LT" it will adopt time in the header as local time
    ra : str, optional
        string to overwrite header RA (Right Ascension) keyword
    dec : str, optional
        string to overwrite header DEC (Declination) keyword
    set_airmass : bool
        Calculate airmass and write it to the header
    time_key : str, optional
        string to point to the main date keyword in FITS header

    Returns
    -------
    hdr : astropy.io.fits.Header
        FITS header unit to be updated
    """

    # set OPD geographic coordinates
    longitude = -(45 + (34 + (57/60))/60)
    latitude = -(22 + (32 + (4/60))/60)
    altitude = 1864*u.m  # hdr['OBSALT']

    # Set geographic coordinates from header if they exist
    if 'OBSLONG' in hdr.keys():
        longitude = hdr['OBSLONG']
    if 'OBSLAT' in hdr.keys():
        latitude = hdr['OBSLAT']
    if 'OBSALT' in hdr.keys():
        altitude = hdr['OBSALT']*u.m  # hdr['OBSALT']

    observatory_location = EarthLocation.from_geodetic(
        lat=latitude, lon=longitude, height=altitude)

    # set equinox to 2000 or get it from header if it exists
    equinox = "J{:.1f}".format(2000.)
    if 'EQUINOX' in hdr.keys():
        equinox = "J{:.1f}".format(hdr['EQUINOX'])

    try:
        if ra == "":
            ra = hdr['RA']
        if dec == "":
            dec = hdr['DEC']
        # set source observed
        source = SkyCoord(ra, dec, unit=(u.hourangle, u.deg),
                          frame='icrs', equinox=equinox)
    except:
        print("WARNING: could not set coordinates RA: {}  DEC: {}. Setting RA=0 Dec=0.".format(ra, dec))
        source = SkyCoord(0, 0, unit="deg")

    radeg, decdeg = source.ra.value, source.dec.value
    # hdr.set("RA_DEG",radeg,"Requested Right Ascension (deg)")
    # hdr.set("DEC_DEG",decdeg,"Requested Declination (deg)")

    # set time zone
    timeZone = TimeDelta(timezone*u.hour, scale='tai')
    # hdr.set("TIMEZONE",timezone,"time zone in hours e.g. BRT = UT - 3 hr")

    # try to set time from DATE-OBS keyword or try the patch if it doesn't work
    try:
        timestr = hdr[time_key]
        obstime = Time(timestr, format='isot', scale='utc',
                       location=observatory_location)
    except:
        # patch for non-standard time format --> change back when headers generated by ACS is fixed
        timestr = "{}-{}-{}".format(hdr[time_key][:4],
                                    hdr[time_key][4:6], hdr[time_key][6:])
        obstime = Time(timestr, format='isot', scale='utc',
                       location=observatory_location)

    hdr.set("DATE-OBS", timestr, "UT date at start of exposure ISOT")

    if timetype == "LT":
        obstime = obstime - timeZone

    jd = obstime.jd
    mjd = obstime.mjd

    # Set light travel time for source observed
    ltt_bary = obstime.light_travel_time(source)
    bjd = obstime.tdb.jd + ltt_bary

    # HJD
    ltt_helio = obstime.light_travel_time(source, 'heliocentric')  # para o HJD
    hjd = obstime.tdb.jd + ltt_helio

    hdr.set("UTDATE", obstime.isot, "UT date at start of exposure ISOT")
    hdr.set("LTDATE", (obstime+timeZone).isot,
            "LT date at start of exposure ISOT")
    hdr.set("JD", jd, "Julian date at start of exposure")
    hdr.set("MJD", mjd, "Modified Julian date at start of exposure")
    hdr.set("BJD", bjd.value, "Barycentric Julian date at start of exposure")
    hdr.set("HJD", hjd.value, "Heliocentric Julian date at start of exposure")

    # sidereal = obstime.sidereal_time('apparent')
    # hdr.set("ST",sidereal,"Sidereal time")
    # hdr.set("SD",sidereal,"Sidereal time")

    if set_airmass:
        # calculate airmass
        airmass = source.transform_to(
            AltAz(obstime=obstime, location=observatory_location)).secz
        hdr.set("AIRMASS", airmass.value, "Airmass at start of exposure")

    return hdr


def identify_files(p, night, print_report=True):
    """ Pipeline module to identify SPARC4 files for reduction
    Parameters
    ----------
    p : dict
        dictionary to store pipeline parameters
    night : str
        Night directory name
    print_report : bool, optional
        Whether or not to print out the report

    Returns
    -------
    p : dict
        dictionary to store pipeline parameters
    """

    data_dir = p['ROOTDATADIR']
    channels = p['CHANNELS']

    inputdata = []
    data_directories = []

    for channel in channels:

        channeldir = '{}/sparc4acs{}/{}/'.format(data_dir, channel, night)

        channelpattern = '{}/sparc4acs{}/{}/*.fits'.format(
            data_dir, channel, night)

        inputdata.append(sorted(glob.glob(channelpattern)))

        data_directories.append(channeldir)

    objects, objsInPhot, objsInPolar = [], [], []
    objectsdata, objsInPhotdata, objsInPolardata = [], [], []
    sciences, dflats, sflats, zeros = [], [], [], []
    darks, foci = [], []
    sciphot, scipolar = [], []
    scipolar_l2, scipolar_l4 = [], []
    objsInPolarL2, objsInPolarL4 = [], []
    objsInPolarL2data, objsInPolarL4data = [], []

    nimgs = 0

    for j in range(len(inputdata)):
        nimgs += len(inputdata[j])

        sflats.append([])
        dflats.append([])
        zeros.append([])
        darks.append([])
        foci.append([])
        sciences.append([])

        objects.append([])
        objsInPhot.append([])
        objsInPolar.append([])

        objectsdata.append({})
        objsInPhotdata.append({})
        objsInPolardata.append({})

        sciphot.append([])
        scipolar.append([])

        scipolar_l2.append([])
        scipolar_l4.append([])
        objsInPolarL2.append([])
        objsInPolarL4.append([])

        objsInPolarL2data.append({})
        objsInPolarL4data.append({})

        for i in range(len(inputdata[j])):
            header = fits.getheader(inputdata[j][i])
            if header["OBSTYPE"] == p['OBJECT_OBSTYPE_KEYVALUE']:
                if "INSTMODE" in header.keys():
                    # print(j,i,inputdata[j][i]," has INSTMODE")
                    pass
                else:
                    print(j, i, inputdata[j][i], " doesn't have INSTMODE")
                    continue

                if header["OBJECT"] not in objects[j]:
                    objects[j].append(header["OBJECT"])
                    objectsdata[j][header["OBJECT"]] = []

                sciences[j].append(inputdata[j][i])
                objectsdata[j][header["OBJECT"]].append(inputdata[j][i])

                if header["INSTMODE"] == p['INSTMODE_PHOTOMETRY_KEYVALUE']:
                    if header["OBJECT"] not in objsInPhot[j]:
                        objsInPhot[j].append(header["OBJECT"])
                        objsInPhotdata[j][header["OBJECT"]] = []
                    sciphot[j].append(inputdata[j][i])
                    objsInPhotdata[j][header["OBJECT"]].append(inputdata[j][i])
                elif header["INSTMODE"] == p['INSTMODE_POLARIMETRY_KEYVALUE']:
                    if header["OBJECT"] not in objsInPolar[j]:
                        objsInPolar[j].append(header["OBJECT"])
                        objsInPolardata[j][header["OBJECT"]] = []
                    scipolar[j].append(inputdata[j][i])
                    objsInPolardata[j][header["OBJECT"]].append(
                        inputdata[j][i])

                    if header["WPSEL"] == 'L2':
                        if header["OBJECT"] not in objsInPolarL2[j]:
                            objsInPolarL2[j].append(header["OBJECT"])
                            objsInPolarL2data[j][header["OBJECT"]] = []
                        objsInPolarL2data[j][header["OBJECT"]].append(
                            inputdata[j][i])
                        scipolar_l2[j].append(inputdata[j][i])
                    elif header["WPSEL"] == 'L4':
                        if header["OBJECT"] not in objsInPolarL4[j]:
                            objsInPolarL4[j].append(header["OBJECT"])
                            objsInPolarL4data[j][header["OBJECT"]] = []
                        objsInPolarL4data[j][header["OBJECT"]].append(
                            inputdata[j][i])
                        scipolar_l4[j].append(inputdata[j][i])

            elif header["OBSTYPE"] == p['FLAT_OBSTYPE_KEYVALUE']:

                if header["OBSTYPE"] == 'SFLAT' or header["OBSTYPE"] == 'SKYFLAT' or header["OBJECT"] == 'SFLAT' or header["OBJECT"] == 'SKYFLAT':
                    sflats[j].append(inputdata[j][i])
                else:
                    dflats[j].append(inputdata[j][i])

            elif header["OBSTYPE"] == p['BIAS_OBSTYPE_KEYVALUE']:
                zeros[j].append(inputdata[j][i])

            elif header["OBSTYPE"] == p['DARK_OBSTYPE_KEYVALUE']:
                darks[j].append(inputdata[j][i])

            elif header["OBSTYPE"] == p['FOCUS_OBSTYPE_KEYVALUE']:
                foci[j].append(inputdata[j][i])

    p['data_directories'] = data_directories
    p['objects'] = objects
    p['sciences'] = sciences
    p['dflats'] = dflats
    p['sflats'] = sflats
    p['zeros'] = zeros
    p['darks'] = darks
    p['foci'] = foci
    p['objsInPhot'], p['objsInPolar'] = objsInPhot, objsInPolar
    p['objectsdata'], p['objsInPhotdata'], p['objsInPolardata'] = objectsdata, objsInPhotdata, objsInPolardata
    p['sciphot'], p['scipolar'] = sciphot, scipolar
    p['scipolar_l2'], p['scipolar_l4'] = scipolar_l2, scipolar_l4
    p['objsInPolarl2'], p['objsInPolarl4'] = objsInPolarL2, objsInPolarL4
    p['objsInPolarL2data'], p['objsInPolarL4data'] = objsInPolarL2data, objsInPolarL4data

    ndflats, nsflats, nzeros, nsci = 0, 0, 0, 0
    ndarks, nfoci = 0, 0
    nsciphot, nscipolar, nscipolar_l2, nscipolar_l4 = 0, 0, 0, 0
    for j in range(len(channels)):
        ndflats += len(dflats[j])
        nsflats += len(sflats[j])
        nzeros += len(zeros[j])
        ndarks += len(darks[j])
        nfoci += len(foci[j])
        nsci += len(sciences[j])

        nsciphot += len(sciphot[j])
        nscipolar += len(scipolar[j])
        nscipolar_l2 += len(scipolar_l2[j])
        nscipolar_l4 += len(scipolar_l4[j])

    if print_report:
        print("***************************************")
        print("********* Night: {} ***********".format(night))
        print("***************************************")
        print("Total number of images : {}".format(nimgs))
        for j in range(len(channels)):
            print("Night dir: {}".format(data_directories[j]))
            print("\tNumber of images in channel {}: {}".format(
                channels[j], len(inputdata[j])))
        print("---------------------------------------")
        print("Total number of calibration images: {}".format(
            ndflats+nsflats+nzeros))
        print("\tNumber of zero images: {}".format(nzeros))
        if nzeros:
            for j in range(len(channels)):
                print("\t\t {} zero images in channel {}".format(
                    len(zeros[j]), channels[j]))

        print("\tNumber of dome flat images: {}".format(ndflats))
        if ndflats:
            for j in range(len(channels)):
                print("\t\t {} dome flat images in channel {}".format(
                    len(dflats[j]), channels[j]))

        print("\tNumber of sky flat images: {}".format(nsflats))
        if nsflats:
            for j in range(len(channels)):
                print("\t\t {} sky flat images in channel {}".format(
                    len(sflats[j]), channels[j]))

        print("\tNumber of dark images: {}".format(ndarks))
        if ndarks:
            for j in range(len(channels)):
                print("\t\t {} dark images in channel {}".format(
                    len(darks[j]), channels[j]))

        print("\tNumber of focus images: {}".format(nfoci))
        if nfoci:
            for j in range(len(channels)):
                print("\t\t {} focus images in channel {}".format(
                    len(foci[j]), channels[j]))

        print("---------------------------------------")
        print("Total number of science images: {}".format(nsci))
        if nsci:
            for j in range(len(channels)):
                print("\t {} science images in channel {}".format(
                    len(sciences[j]), channels[j]))

        print("\tTotal number of images in PHOT: {}".format(nsciphot))
        if nsciphot:
            for j in range(len(channels)):
                print("\t\t {} PHOT images in channel {}".format(
                    len(sciphot[j]), channels[j]))

        print("\tTotal number of images in POLAR: {}".format(nscipolar))
        if nscipolar:
            for j in range(len(channels)):
                print("\t\t {} POLAR images in channel {}".format(
                    len(scipolar[j]), channels[j]))

        print("\t\tNumber of POLAR images in L/2: {}".format(nscipolar_l2))
        if nscipolar_l2:
            for j in range(len(channels)):
                print(
                    "\t\t\t {} POLAR L/2 images in channel {}".format(len(scipolar_l2[j]), channels[j]))
        print("\t\tNumber of POLAR images in L/4: {}".format(nscipolar_l4))
        if nscipolar_l4:
            for j in range(len(channels)):
                print(
                    "\t\t\t {} POLAR L/4 images in channel {}".format(len(scipolar_l4[j]), channels[j]))
        print("---------------------------------------")
        for j in range(len(channels)):
            print("Total number of objects observed in channel {}: {}".format(
                channels[j], len(objects[j])))

            for object in objects[j]:
                print("\t{} has {} images in channel {}".format(
                    object, len(objectsdata[j][object]), channels[j]))

            print("\t\t {} objects observed in PHOT ".format(
                len(objsInPhot[j])))
            for object in objsInPhot[j]:
                print("\t\t\t{} has {} images in PHOT".format(
                    object, len(objsInPhotdata[j][object])))

            print("\t\t {} objects observed in POLAR ".format(
                len(objsInPolar[j])))
            for object in objsInPolar[j]:
                print("\t\t\t{} has {} images".format(
                    object, len(objsInPolardata[j][object])))

            print(
                "\t\t {} objects observed in POLAR L/2".format(len(objsInPolarL2[j])))
            for object in objsInPolarL2[j]:
                print("\t\t\t{} has {} images".format(
                    object, len(objsInPolarL2data[j][object])))

            print(
                "\t\t {} objects observed in POLAR L/4".format(len(objsInPolarL4[j])))
            for object in objsInPolarL4[j]:
                print("\t\t\t{} has {} images".format(
                    object, len(objsInPolarL4data[j][object])))
            print("---------------------------------------")
        print("***************************************")

    return p


def select_polar_sequences(list_of_files, sortlist=True, verbose=False):
    """ Pipeline module to select polarimetric sequences
    Parameters
    ----------
    list_of_files : list
        list of files
    sortlist : bool
        sort input list of files
    verbose : bool
        turn on verbose

    Returns
    -------
    sequences : list
        list of sequences, where each sequence is a list of files
    """

    sortedlist = deepcopy(list_of_files)
    if sortlist:
        # make sure the input list is sorted
        sortedlist = sorted(sortedlist)

    # initialize list of sequences
    sequences = []

    # run only for a non-empty list
    if len(sortedlist):

        # save WPPOS of first image
        prev_pos = fits.getheader(sortedlist[0])['WPPOS']
        # init current sequence list
        seq = []

        for i in range(len(sortedlist)):

            # get current WPPOS from header
            current_pos = fits.getheader(sortedlist[i])["WPPOS"]

            # if current pos is lower than previous it means a new
            # sequence started -> increment sequences and reset seq
            if current_pos < prev_pos:
                sequences.append(seq)
                if verbose:
                    print("Adding seq {} of {} files".format(
                        len(sequences), len(seq)))

                seq = []

            # append file to current seq
            seq.append(sortedlist[i])
            # save current position as previous position
            prev_pos = current_pos

            # Reached last file, add seq to sequences
            if i == len(sortedlist) - 1:
                sequences.append(seq)
                if verbose:
                    print("Adding seq {} of {} files".format(
                        len(sequences), len(seq)))

    return sequences
