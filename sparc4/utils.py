"""
    Created on Nov 28 2022

    Description: Library of useful recipes for the SPARC4 pipeline

    @author: Eder Martioli <emartioli@lna.br>

    Laboratório Nacional de Astrofísica - LNA/MCTI
    """

import os, sys
import glob
from copy import deepcopy

from astropy import units as u
from astropy.coordinates import AltAz, EarthLocation, SkyCoord
from astropy.io import fits
from astropy.time import Time, TimeDelta

import twirl
import matplotlib.pyplot as plt
from astropy.wcs import WCS
from astropy.wcs.utils import proj_plane_pixel_scales
import photutils
import numpy as np

def set_timecoords_keys(hdr, timezone=-3, timetype="", ra="", dec="",
                        set_airmass=True, time_key='DATE-OBS', exptimekey='EXPTIME'):
    """ Pipeline module to set time and coordinates keywords
    Parameters
    ----------
    hdr : astropy.io.fits.Header
        FITS header unit to be updated
    timezone : int, optional
        Time zone of observations with respect to Greenwich.
        Default value is OPD's time zone of -3h
    timetype : str, optional
        if timetype=="LT" it will adopt time in the header as local time
    ra : str, optional
        string to overwrite header RA (Right Ascension) keyword
    dec : str, optional
        string to overwrite header DEC (Declination) keyword
    set_airmass : bool
        Calculate airmass and write it to the header
    time_key : str, optional
        string to point to the main date keyword in FITS header
    exptimekey : str, optional
        string to point to the exposure time (in units of s) keyword in FITS header

    Returns
    -------
    hdr : astropy.io.fits.Header
        FITS header unit to be updated
    """

    # set OPD geographic coordinates
    longitude = -(45 + (34 + (57/60))/60)
    latitude = -(22 + (32 + (4/60))/60)
    altitude = 1864*u.m  # hdr['OBSALT']

    # Set geographic coordinates from header if they exist
    if 'OBSLONG' in hdr.keys():
        longitude = hdr['OBSLONG']
    if 'OBSLAT' in hdr.keys():
        latitude = hdr['OBSLAT']
    if 'OBSALT' in hdr.keys():
        altitude = hdr['OBSALT']*u.m  # hdr['OBSALT']

    observatory_location = EarthLocation.from_geodetic(
        lat=latitude, lon=longitude, height=altitude)

    # set equinox to 2000 or get it from header if it exists
    equinox = "J{:.1f}".format(2000.)
    if 'EQUINOX' in hdr.keys():
        equinox = "J{:.1f}".format(hdr['EQUINOX'])

    try:
        if ra == "":
            ra = hdr['RA']
        if dec == "":
            dec = hdr['DEC']
        # set source observed
        source = SkyCoord(ra, dec, unit=(u.hourangle, u.deg),
                          frame='icrs', equinox=equinox)
    except:
        print("WARNING: could not set coordinates RA: {}  DEC: {}. Setting RA=0 Dec=0.".format(ra, dec))
        source = SkyCoord(0, 0, unit="deg")

    radeg, decdeg = source.ra.value, source.dec.value
    # hdr.set("RA_DEG",radeg,"Requested Right Ascension (deg)")
    # hdr.set("DEC_DEG",decdeg,"Requested Declination (deg)")

    # set time zone
    timeZone = TimeDelta(timezone*u.hour, scale='tai')
    # hdr.set("TIMEZONE",timezone,"time zone in hours e.g. BRT = UT - 3 hr")

    # try to set time from DATE-OBS keyword or try the patch if it doesn't work
    try:
        timestr = hdr[time_key]
        obstime = Time(timestr, format='isot', scale='utc',
                       location=observatory_location)
    except:
        # patch for non-standard time format --> change back when headers generated by ACS is fixed
        timestr = "{}-{}-{}".format(hdr[time_key][:4],
                                    hdr[time_key][4:6], hdr[time_key][6:])
        obstime = Time(timestr, format='isot', scale='utc',
                       location=observatory_location)

    hdr.set("DATE-OBS", timestr, "UT date at start of exposure ISOT")

    if timetype == "LT":
        obstime = obstime - timeZone

    hdr.set("UTDATE", obstime.isot, "UT date at start of exposure ISOT")
    hdr.set("LTDATE", (obstime+timeZone).isot,"LT date at start of exposure ISOT")

    jd = obstime.jd
    mjd = obstime.mjd

    # Set light travel time for source observed
    ltt_bary = obstime.light_travel_time(source)
    bjd = obstime.tdb.jd + ltt_bary

    # HJD
    ltt_helio = obstime.light_travel_time(source, 'heliocentric')  # para o HJD
    hjd = obstime.tdb.jd + ltt_helio

    exptime = TimeDelta(get_exptime(hdr,exptimekey=exptimekey), format='sec')

    midjd = (obstime+exptime/2).jd
    midmjd = (obstime+exptime/2).mjd

    hdr.set("JD", midjd, "Julian date at middle of exposure")
    hdr.set("MJD", midmjd, "Modified Julian date at middle of exposure")
    hdr.set("BJD", (bjd+exptime/2).value, "Barycentric Julian date at middle of exposure")
    hdr.set("HJD", (hjd+exptime/2).value, "Heliocentric Julian date at middle of exposure")

    hdr.set("STARTJD", jd, "Julian date at start of exposure")
    hdr.set("STARTMJD", mjd, "Modified Julian date at start of exposure")
    hdr.set("STARTBJD", bjd.value, "Barycentric Julian date at start of exposure")
    hdr.set("STARTHJD", hjd.value, "Heliocentric Julian date at start of exposure")

    # sidereal = obstime.sidereal_time('apparent')
    # hdr.set("ST",sidereal,"Sidereal time")
    # hdr.set("SD",sidereal,"Sidereal time")

    if set_airmass:
        # calculate airmass
        airmass = source.transform_to(
            AltAz(obstime=obstime, location=observatory_location)).secz
        hdr.set("AIRMASS", airmass.value, "Airmass at start of exposure")

    return hdr


def get_exptime(header, exptimekey="EXPTIME") :
    """ Pipeline module to get exposure time from header
    Parameters
    ----------
    header : astropy fits header
        header containing exptime
        
    exptimekey : str
        header keyword for exposure time
    Returns
    -------
    exptime : float
        exposure time in units of seconds
    """
    exptime = header[exptimekey]
    if type(exptime) == str:
        if ',' in exptime :
            exptime = exptime.replace(",", ".")
        exptime = float(exptime)
        
    return exptime


def identify_files(p, night, print_report=True):
    """ Pipeline module to identify SPARC4 files for reduction
    Parameters
    ----------
    p : dict
        dictionary to store pipeline parameters
    night : str
        Night directory name
    print_report : bool, optional
        Whether or not to print out the report

    Returns
    -------
    p : dict
        dictionary to store pipeline parameters
    """

    data_dir = p['ROOTDATADIR']
    channels = p['CHANNELS']

    inputdata = []
    data_directories = []

    for channel in channels:

        channeldir = '{}/sparc4acs{}/{}/'.format(data_dir, channel, night)

        channelpattern = '{}/sparc4acs{}/{}/*.fits'.format(
            data_dir, channel, night)

        inputdata.append(sorted(glob.glob(channelpattern)))

        data_directories.append(channeldir)

    objects, objsInPhot, objsInPolar = [], [], []
    objectsdata, objsInPhotdata, objsInPolardata = [], [], []
    sciences, dflats, sflats, zeros = [], [], [], []
    darks, foci = [], []
    sciphot, scipolar = [], []
    scipolar_l2, scipolar_l4 = [], []
    objsInPolarL2, objsInPolarL4 = [], []
    objsInPolarL2data, objsInPolarL4data = [], []

    nimgs = 0

    for j in range(len(inputdata)):
        nimgs += len(inputdata[j])

        sflats.append([])
        dflats.append([])
        zeros.append([])
        darks.append([])
        foci.append([])
        sciences.append([])

        objects.append([])
        objsInPhot.append([])
        objsInPolar.append([])

        objectsdata.append({})
        objsInPhotdata.append({})
        objsInPolardata.append({})

        sciphot.append([])
        scipolar.append([])

        scipolar_l2.append([])
        scipolar_l4.append([])
        objsInPolarL2.append([])
        objsInPolarL4.append([])

        objsInPolarL2data.append({})
        objsInPolarL4data.append({})

        for i in range(len(inputdata[j])):
            header = fits.getheader(inputdata[j][i])
            if header["OBSTYPE"] == p['OBJECT_OBSTYPE_KEYVALUE']:
                if "INSTMODE" in header.keys():
                    # print(j,i,inputdata[j][i]," has INSTMODE")
                    pass
                else:
                    print(j, i, inputdata[j][i], " doesn't have INSTMODE")
                    continue

                if header["OBJECT"] not in objects[j]:
                    objects[j].append(header["OBJECT"])
                    objectsdata[j][header["OBJECT"]] = []

                sciences[j].append(inputdata[j][i])
                objectsdata[j][header["OBJECT"]].append(inputdata[j][i])

                if header["INSTMODE"] == p['INSTMODE_PHOTOMETRY_KEYVALUE']:
                    if header["OBJECT"] not in objsInPhot[j]:
                        objsInPhot[j].append(header["OBJECT"])
                        objsInPhotdata[j][header["OBJECT"]] = []
                    sciphot[j].append(inputdata[j][i])
                    objsInPhotdata[j][header["OBJECT"]].append(inputdata[j][i])
                elif header["INSTMODE"] == p['INSTMODE_POLARIMETRY_KEYVALUE']:
                    if header["OBJECT"] not in objsInPolar[j]:
                        objsInPolar[j].append(header["OBJECT"])
                        objsInPolardata[j][header["OBJECT"]] = []
                    scipolar[j].append(inputdata[j][i])
                    objsInPolardata[j][header["OBJECT"]].append(
                        inputdata[j][i])

                    if header["WPSEL"] == 'L2':
                        if header["OBJECT"] not in objsInPolarL2[j]:
                            objsInPolarL2[j].append(header["OBJECT"])
                            objsInPolarL2data[j][header["OBJECT"]] = []
                        objsInPolarL2data[j][header["OBJECT"]].append(
                            inputdata[j][i])
                        scipolar_l2[j].append(inputdata[j][i])
                    elif header["WPSEL"] == 'L4':
                        if header["OBJECT"] not in objsInPolarL4[j]:
                            objsInPolarL4[j].append(header["OBJECT"])
                            objsInPolarL4data[j][header["OBJECT"]] = []
                        objsInPolarL4data[j][header["OBJECT"]].append(
                            inputdata[j][i])
                        scipolar_l4[j].append(inputdata[j][i])

            elif header["OBSTYPE"] == p['FLAT_OBSTYPE_KEYVALUE']:

                if header["OBSTYPE"] == 'SFLAT' or header["OBSTYPE"] == 'SKYFLAT' or header["OBJECT"] == 'SFLAT' or header["OBJECT"] == 'SKYFLAT':
                    sflats[j].append(inputdata[j][i])
                else:
                    dflats[j].append(inputdata[j][i])

            elif header["OBSTYPE"] == p['BIAS_OBSTYPE_KEYVALUE']:
                zeros[j].append(inputdata[j][i])

            elif header["OBSTYPE"] == p['DARK_OBSTYPE_KEYVALUE']:
                darks[j].append(inputdata[j][i])

            elif header["OBSTYPE"] == p['FOCUS_OBSTYPE_KEYVALUE']:
                foci[j].append(inputdata[j][i])

    p['data_directories'] = data_directories
    p['objects'] = objects
    p['sciences'] = sciences
    p['dflats'] = dflats
    p['sflats'] = sflats
    p['zeros'] = zeros
    p['darks'] = darks
    p['foci'] = foci
    p['objsInPhot'], p['objsInPolar'] = objsInPhot, objsInPolar
    p['objectsdata'], p['objsInPhotdata'], p['objsInPolardata'] = objectsdata, objsInPhotdata, objsInPolardata
    p['sciphot'], p['scipolar'] = sciphot, scipolar
    p['scipolar_l2'], p['scipolar_l4'] = scipolar_l2, scipolar_l4
    p['objsInPolarl2'], p['objsInPolarl4'] = objsInPolarL2, objsInPolarL4
    p['objsInPolarL2data'], p['objsInPolarL4data'] = objsInPolarL2data, objsInPolarL4data

    ndflats, nsflats, nzeros, nsci = 0, 0, 0, 0
    ndarks, nfoci = 0, 0
    nsciphot, nscipolar, nscipolar_l2, nscipolar_l4 = 0, 0, 0, 0
    for j in range(len(channels)):
        ndflats += len(dflats[j])
        nsflats += len(sflats[j])
        nzeros += len(zeros[j])
        ndarks += len(darks[j])
        nfoci += len(foci[j])
        nsci += len(sciences[j])

        nsciphot += len(sciphot[j])
        nscipolar += len(scipolar[j])
        nscipolar_l2 += len(scipolar_l2[j])
        nscipolar_l4 += len(scipolar_l4[j])

    if print_report:
        print("***************************************")
        print("********* Night: {} ***********".format(night))
        print("***************************************")
        print("Total number of images : {}".format(nimgs))
        for j in range(len(channels)):
            print("Night dir: {}".format(data_directories[j]))
            print("\tNumber of images in channel {}: {}".format(
                channels[j], len(inputdata[j])))
        print("---------------------------------------")
        print("Total number of calibration images: {}".format(
            ndflats+nsflats+nzeros))
        print("\tNumber of zero images: {}".format(nzeros))
        if nzeros:
            for j in range(len(channels)):
                print("\t\t {} zero images in channel {}".format(
                    len(zeros[j]), channels[j]))

        print("\tNumber of dome flat images: {}".format(ndflats))
        if ndflats:
            for j in range(len(channels)):
                print("\t\t {} dome flat images in channel {}".format(
                    len(dflats[j]), channels[j]))

        print("\tNumber of sky flat images: {}".format(nsflats))
        if nsflats:
            for j in range(len(channels)):
                print("\t\t {} sky flat images in channel {}".format(
                    len(sflats[j]), channels[j]))

        print("\tNumber of dark images: {}".format(ndarks))
        if ndarks:
            for j in range(len(channels)):
                print("\t\t {} dark images in channel {}".format(
                    len(darks[j]), channels[j]))

        print("\tNumber of focus images: {}".format(nfoci))
        if nfoci:
            for j in range(len(channels)):
                print("\t\t {} focus images in channel {}".format(
                    len(foci[j]), channels[j]))

        print("---------------------------------------")
        print("Total number of science images: {}".format(nsci))
        if nsci:
            for j in range(len(channels)):
                print("\t {} science images in channel {}".format(
                    len(sciences[j]), channels[j]))

        print("\tTotal number of images in PHOT: {}".format(nsciphot))
        if nsciphot:
            for j in range(len(channels)):
                print("\t\t {} PHOT images in channel {}".format(
                    len(sciphot[j]), channels[j]))

        print("\tTotal number of images in POLAR: {}".format(nscipolar))
        if nscipolar:
            for j in range(len(channels)):
                print("\t\t {} POLAR images in channel {}".format(
                    len(scipolar[j]), channels[j]))

        print("\t\tNumber of POLAR images in L/2: {}".format(nscipolar_l2))
        if nscipolar_l2:
            for j in range(len(channels)):
                print(
                    "\t\t\t {} POLAR L/2 images in channel {}".format(len(scipolar_l2[j]), channels[j]))
        print("\t\tNumber of POLAR images in L/4: {}".format(nscipolar_l4))
        if nscipolar_l4:
            for j in range(len(channels)):
                print(
                    "\t\t\t {} POLAR L/4 images in channel {}".format(len(scipolar_l4[j]), channels[j]))
        print("---------------------------------------")
        for j in range(len(channels)):
            print("Total number of objects observed in channel {}: {}".format(
                channels[j], len(objects[j])))

            for object in objects[j]:
                print("\t{} has {} images in channel {}".format(
                    object, len(objectsdata[j][object]), channels[j]))

            print("\t\t {} objects observed in PHOT ".format(
                len(objsInPhot[j])))
            for object in objsInPhot[j]:
                print("\t\t\t{} has {} images in PHOT".format(
                    object, len(objsInPhotdata[j][object])))

            print("\t\t {} objects observed in POLAR ".format(
                len(objsInPolar[j])))
            for object in objsInPolar[j]:
                print("\t\t\t{} has {} images".format(
                    object, len(objsInPolardata[j][object])))

            print(
                "\t\t {} objects observed in POLAR L/2".format(len(objsInPolarL2[j])))
            for object in objsInPolarL2[j]:
                print("\t\t\t{} has {} images".format(
                    object, len(objsInPolarL2data[j][object])))

            print(
                "\t\t {} objects observed in POLAR L/4".format(len(objsInPolarL4[j])))
            for object in objsInPolarL4[j]:
                print("\t\t\t{} has {} images".format(
                    object, len(objsInPolarL4data[j][object])))
            print("---------------------------------------")
        print("***************************************")

    return p


def select_polar_sequences(list_of_files, sortlist=True, npos_in_seq=16, rolling_seq=False, verbose=False):
    """ Pipeline module to select polarimetric sequences
    Parameters
    ----------
    list_of_files : list
        list of files
    sortlist : bool
        sort input list of files
    npos_in_seq : int
        to set number of waveplate positions in each sequence
    rolling_seq : bool
        switch to create rolling polar sequences, e.g. seqs[1234,2345,3456,4567,...]
    verbose : bool
        turn on verbose

    Returns
    -------
    sequences : list
        list of sequences, where each sequence is a list of files
    """

    sortedlist = deepcopy(list_of_files)
    if sortlist:
        # make sure the input list is sorted
        sortedlist = sorted(sortedlist)

    # initialize list of sequences
    sequences = []

    # run only for a non-empty list
    if len(sortedlist):
        
        # save WPPOS of first image
        prev_pos = fits.getheader(sortedlist[0])['WPPOS']
        
        block_index = 0
        blocks, block_pos = [], []
        blocks.append([])
        
        blocks[block_index].append(sortedlist[0])
        block_pos.append(prev_pos)
                
        for i in range(1,len(sortedlist)) :
            # save WPPOS of first image
            pos = fits.getheader(sortedlist[i])['WPPOS']
            
            if pos != prev_pos :
                prev_pos = pos
                block_index += 1
                blocks.append([])
                block_pos.append(prev_pos)
                
            blocks[block_index].append(sortedlist[i])
          
        number_of_blocks = len(block_pos)
        sequences.append([])
        blocksinseq = []
        seq_index = 0

        if rolling_seq :
            
            for j in range(len(block_pos)) :
                pos_in_seq = []
                
                lastjj = j + npos_in_seq
                
                if lastjj > len(block_pos) :
                    lastjj = len(block_pos)
                
                for jj in range(j,lastjj) :
                    if block_pos[jj] not in pos_in_seq :
                        for i in range(len(blocks[jj])) :
                            sequences[seq_index].append(blocks[jj][i])
                        pos_in_seq.append(block_pos[jj])
                                                    
                blocksinseq.append(len(pos_in_seq))
                
                if lastjj == len(block_pos) :
                    break

                sequences.append([])
                seq_index += 1
                
        else :
            nblocks_in_sequence = 0
        
            #--
            prev_block_pos = block_pos[0]
            for i in range(len(blocks[0])) :
                sequences[seq_index].append(blocks[0][i])
            nblocks_in_sequence += 1
            #--
            
            for j in range(1,len(block_pos)) :
    
                # reset sequence
                if nblocks_in_sequence == npos_in_seq or block_pos[j] < prev_block_pos :
                    sequences.append([])
                    seq_index += 1
                    blocksinseq.append(nblocks_in_sequence)
                    nblocks_in_sequence = 0
                    
                #--
                prev_block_pos = block_pos[j]
                for i in range(len(blocks[j])) :
                    sequences[seq_index].append(blocks[j][i])
                nblocks_in_sequence += 1
                if j==len(block_pos)-1:
                    blocksinseq.append(nblocks_in_sequence)
                #--
            
        if verbose :
            for k in range(len(sequences)) :
                print("Sequence {} of {} : {} files for {} waveplate positions".format(k+1,len(sequences),len(sequences[k]),blocksinseq[k]))
            
    return sequences



def select_fits_files_with_keyword(list_of_files, keyword, value):

    """ Pipeline tool to select FITS files matching a given keyword value
    Parameters
    ----------
    list_of_files : list
        input list of files
    keyword : str
        FITS keyword to match
    value : *
        keyword value to compare and match selected files

    Returns
    -------
    matching_files : list
        list of files
    """

    matching_files = []
    
    for i in range(len(list_of_files)):
        if list_of_files[i].endswith(".fits"):
            # Open the FITS file and read the header
            with fits.open(list_of_files[i]) as hdul:
                header = hdul[0].header
                # Check if the keyword exists and matches the desired value
                if keyword in header and header[keyword] == value:
                    matching_files.append(list_of_files[i])
    
    return matching_files


def check_astrometry(filename, fov_search_factor=2.0, apply_sparsify_filter=False, sparsify_factor=0.01, nsources_to_plot=30) :

    """ Pipeline module to calcualte astrometric solution from an existing wcs
    Parameters
    ----------
    filename : str
        fits file name

    Returns
        wcs : astropy.wcs.WCS

    -------
    """

    # load fits image
    hdul = fits.open(filename)
    img_data, hdr = hdul[0].data, hdul[0].header
    
    #print(repr(hdr))
    
    # load wcs from input header
    w = WCS(hdr,naxis=2)
    
    fov = (img_data.shape * proj_plane_pixel_scales(w))[0]
    center = w.pixel_to_world(*np.array(img_data.shape) / 2)
    
    # get RAs and Decs from Gaia catalog for a sky area of 2 x FoV
    gaia_sources_skycoords = twirl.gaia_radecs(center, fov_search_factor * fov)
    
    # we only keep stars 0.01 degree apart from each other
    if apply_sparsify_filter :
        gaia_sources_skycoords = twirl.geometry.sparsify(gaia_sources_skycoords, sparsify_factor)
    
    # use input wcs to generate a "guess" for the set of pixel coordinates of Gaia sources
    gaia_sources_pixcoords = np.array(w.world_to_pixel_values(gaia_sources_skycoords))
    
    plt.imshow(img_data, vmin=np.median(img_data), vmax=3 * np.median(img_data), cmap="Greys_r")
    _ = photutils.aperture.CircularAperture(gaia_sources_pixcoords[:nsources_to_plot], r=10.0).plot(color="y")
    plt.show()

    return w
